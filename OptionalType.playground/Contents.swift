//: Playground - noun: a place where people can play

import Foundation

var str = "Hello, playground"
///
//可选类型

//
//所谓可选类型就是一个变量或常量可能有值也可能没有值则设置为可选类型。在ObjC中如果一个对象类型没有赋值，则默认为nil，同时nil类型也只能作为对象类型的默认值，对于类似于Int等基本类型则对应0这样的默认值。由于Swift是强类型语言，如果在声明变量或常量时没有进行赋值，Swift并不会默认设置初值（这一点和其他高级语言不太一样，例如C#虽然也有可选类型，但是要求并没有那么严格）。


var x:Float?  //使用？声明一个可选类型，如果不赋值默认为nil
x = 12.1

var y:Float = 60.0
//var z=x+y //注意此句报错，因为Int和Int？根本就是两种不同的类型，在Swift中两种不同的类型不能运算（因为不会自动进行类型转化）

var z=x!+y //使用！进行强制解包
var age="29"
var ageInt=age.toInt() //注意ageInt是Int可选类型而不是Int类型（因为String的toInt()方法并不能保证其一定能转化为Int类型）


//Swift中类似于Int和Int?并不是同一种类型，不能进行相关运算，如果要运算只能解包；
//可选类型其本质就是此类型内部存储分为“Some”和“None”两个部分，如果有值则存储到“Some”中，没有值则为“None”（早期Playground中可以看到两个部分，如今已经取消显示Some等描述了），使用感叹号强制解包的过程就是取出“Some”部分；
//
//既然可选类型有可能有值，也可能没有值那么往往有时候就需要判断。可以使用if直接判断一个可选类型是否为nil，这样一来就可以根据情况进行强制解包（从Some部分取出值的过程）；另一个选择就是在判断的同时如果有值则将值赋值给一个临时变量或常量，否则不进入此条件语句，这个过程称之为“可选绑定”。


//可选类型判断
var age2 = "99"
var ageInt2 = age2.toInt()
if ageInt2 == nil {
    println("ageInt=nil")
}else{
    println("ageInt = \(ageInt2!)")
    
}

//可选类型绑定
//如果可选类型有值则将值赋值给一个临时变量或者常量（此时此变量或者常量接受的值已经不是可选类型），如果没有值则不执行此条件

if let newAge = ageInt { //此时newAge可以定义成常量也可以定义成变量
    println("newAge=\(newAge)") //注意这里并不需要对newAge强制解包
}else{
    println("ageInt=nil")
}


//
//通过前面的演示可以看出Swift中的可选绑定如果实际计算不得不进行强制解包，如果一个可选类型从第一次赋值之后就能保证有值那么使用时就不必进行强制解包了，这种情况下可以使用隐式可选解析类型（通过感叹号声明而不是问号）

var age3:Int! = 0 //通过感叹号声明隐式解析可选类型，此后使用时虽然是可选类型但是不用强制解包
age3 = 29
var newAge3:Int = age3//不用强制解包直接赋值给Int类型（程序会自动解包）

if var tempAge=age3 {
    println("tempAge=\(tempAge)")
}else{
    println("age=nil")
}


//
//
//运算符
//
//Swift中支持绝大多数C语言的运算符并改进以减少不必要的错误（例如等号赋值后不返回值），算术运算会检查溢出情况，必要时还能使用新增的溢出运算符。另外Swift中还可以对浮点数使用取余运算符，新增了区间运算符。对于基本的运算符这里不再一一介绍，简单看一下Swift中的区间运算符和溢出运算符。


/**
* 区间运算符,通常用于整形或者字符范围(例如"a"..."z"）
*/
for i in 1...5 { //闭区间运算符...（从1到5，包含5）
    println("i=\(i)")
}

for i in 1..<5{ //半开区间运算符..<(从1到4)
    println("i=\(i)")
}

var str2 = "hello world."
var range = "a"..."z"
for t in str2 {
    if range.contains(String(t)) {
       println(t)
    }
}

/**
* 溢出运算符
*/
var a=UInt8.max //a=255
//var b:UInt8=a+1 //注意b会出现溢出,此句报错

//下面使用溢出运算符，结果为：0，类似的还有&-、&*、&/
//使用溢出运算符可以在最大值和最小值之前循环而不会报错
var b:UInt8=a &+ 1

// 溢出运算符的原理其实很简单，例如对于UInt8，如果8位均为1则十进制表示是255，但是当加1之后则变成了9位“100000000”，出现了溢出但是UInt8本身值只能存储8位，所以取后面8位就变成了“00000000”，十进制表示就是0。
